<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module erqwest</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module erqwest</h1>
<ul class="index"><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>


<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-client">client()</a></h3>
<p><b>abstract datatype</b>: <tt>client()</tt></p>


<h3 class="typedecl"><a name="type-client_opts">client_opts()</a></h3>
<p><tt>client_opts() = #{identity =&gt; {Pkcs12Der::binary(), Password::binary()}, follow_redirects =&gt; boolean() | non_neg_integer(), additional_root_certs =&gt; [CertDer::binary()], use_built_in_root_certs =&gt; boolean(), danger_accept_invalid_hostnames =&gt; boolean(), danger_accept_invalid_certs =&gt; boolean(), proxy =&gt; system | no_proxy | <a href="#type-proxy_config">proxy_config()</a>, connect_timeout =&gt; <a href="#type-timeout_ms">timeout_ms()</a>, timeout =&gt; <a href="#type-timeout_ms">timeout_ms()</a>, pool_idle_timeout =&gt; <a href="#type-timeout_ms">timeout_ms()</a>, pool_max_idle_per_host =&gt; non_neg_integer(), https_only =&gt; boolean(), cookie_store =&gt; boolean(), gzip =&gt; boolean()}</tt></p>


<h3 class="typedecl"><a name="type-err">err()</a></h3>
<p><tt>err() = #{code := timeout | redirect | url | connect | request | body | cancelled | unknown, reason := binary()}</tt></p>


<h3 class="typedecl"><a name="type-feature">feature()</a></h3>
<p><tt>feature() = cookies | gzip</tt></p>


<h3 class="typedecl"><a name="type-handle">handle()</a></h3>
<p><b>abstract datatype</b>: <tt>handle()</tt></p>


<h3 class="typedecl"><a name="type-header">header()</a></h3>
<p><tt>header() = {binary(), binary()}</tt></p>


<h3 class="typedecl"><a name="type-method">method()</a></h3>
<p><tt>method() = options | get | post | put | delete | head | trace | connect | patch</tt></p>


<h3 class="typedecl"><a name="type-proxy_config">proxy_config()</a></h3>
<p><tt>proxy_config() = [{http | https | all, <a href="#type-proxy_spec">proxy_spec()</a>}]</tt></p>


<h3 class="typedecl"><a name="type-proxy_spec">proxy_spec()</a></h3>
<p><tt>proxy_spec() = #{url := binary(), basic_auth =&gt; {Username::binary(), Password::binary()}}</tt></p>


<h3 class="typedecl"><a name="type-read_opts">read_opts()</a></h3>
<p><tt>read_opts() = #{period =&gt; <a href="#type-timeout_ms">timeout_ms()</a>, length =&gt; pos_integer()}</tt></p>


<h3 class="typedecl"><a name="type-req_opts">req_opts()</a></h3>
<p><tt>req_opts() = #{url := binary(), method := <a href="#type-method">method()</a>, headers =&gt; [<a href="#type-header">header()</a>], body =&gt; iodata() | stream, response_body =&gt; complete | stream, timeout =&gt; <a href="#type-timeout_ms">timeout_ms()</a>}</tt></p>


<h3 class="typedecl"><a name="type-req_opts_optional">req_opts_optional()</a></h3>
<p><tt>req_opts_optional() = #{headers =&gt; [<a href="#type-header">header()</a>], body =&gt; iodata() | stream, timeout =&gt; <a href="#type-timeout_ms">timeout_ms()</a>, body =&gt; iodata() | stream, response_body =&gt; complete | stream}</tt></p>


<h3 class="typedecl"><a name="type-resp">resp()</a></h3>
<p><tt>resp() = #{status := 100..599, body := binary() | <a href="#type-handle">handle()</a>, headers := [<a href="#type-header">header()</a>]}</tt></p>


<h3 class="typedecl"><a name="type-timeout_ms">timeout_ms()</a></h3>
<p><tt>timeout_ms() = non_neg_integer() | infinity</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cancel-1">cancel/1</a></td><td>Used to cancel streaming of a request or response body.</td></tr>
<tr><td valign="top"><a href="#close_client-1">close_client/1</a></td><td>Close a client and idle connections in its pool.</td></tr>
<tr><td valign="top"><a href="#delete-3">delete/3</a></td><td>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#feature-1">feature/1</a></td><td>Determines whether a compile-time feature is available.</td></tr>
<tr><td valign="top"><a href="#finish_send-1">finish_send/1</a></td><td>Complete sending the request body.</td></tr>
<tr><td valign="top"><a href="#get-2">get/2</a></td><td>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#get-3">get/3</a></td><td>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#make_client-0">make_client/0</a></td><td>Equivalent to <a href="#make_client-1"><tt>make_client(#{})</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#make_client-1">make_client/1</a></td><td>Make a new client with its own connection pool.</td></tr>
<tr><td valign="top"><a href="#patch-3">patch/3</a></td><td>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#post-3">post/3</a></td><td>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#put-3">put/3</a></td><td>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#read-1">read/1</a></td><td>Equivalent to <a href="#read-2"><tt>read(Handle, #{})</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read a chunk of the response body, waiting for at most <code>period</code> ms or
  until at least <code>length</code> bytes have been read.</td></tr>
<tr><td valign="top"><a href="#req-2">req/2</a></td><td>Make a synchronous request.</td></tr>
<tr><td valign="top"><a href="#send-2">send/2</a></td><td>Stream a chunk of the request body.</td></tr>
<tr><td valign="top"><a href="#start_client-1">start_client/1</a></td><td>Equivalent to <a href="#start_client-2"><tt>start_client(Name, #{})</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#start_client-2">start_client/2</a></td><td>Start a client registered under <code>Name</code>.</td></tr>
<tr><td valign="top"><a href="#stop_client-1">stop_client/1</a></td><td>Unregisters and calls <a docgen-rel="seemfa" docgen-href="#close_client/1" href="#close_client-1"><code>close_client/1</code></a> on a named client.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="cancel-1">cancel/1</a></h3>
<div class="spec">
<p><tt>cancel(Handle::<a href="#type-handle">handle()</a>) -&gt; ok</tt><br></p>
<p> </p>
</div><p>Used to cancel streaming of a request or response body.</p>

<h3 class="function"><a name="close_client-1">close_client/1</a></h3>
<div class="spec">
<p><tt>close_client(Client::<a href="#type-client">client()</a>) -&gt; ok</tt><br></p>
<p> </p>
</div><p><p>Close a client and idle connections in its pool. Returns immediately,  
but the connection pool will not be cleaned up until all in-flight requests  
for this client have returned.</p>
 
  <p>You do not have to call this function, since  
the client will automatically be cleaned up when it is garbage collected by  
the VM.</p>
 
  Fails with reason badarg if the client has already been closed.</p>

<h3 class="function"><a name="delete-3">delete/3</a></h3>
<div class="spec">
<p><tt>delete(Client::<a href="#type-client">client()</a> | atom(), Url::binary(), Opts::<a href="#type-req_opts_optional">req_opts_optional()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="feature-1">feature/1</a></h3>
<div class="spec">
<p><tt>feature(Feature::<a href="#type-feature">feature()</a>) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p>Determines whether a compile-time feature is available. Enable features
  by adding them to the environment variable <code>ERQWEST_FEATURES</code> (comma
  separated list) at build time.</p>

<h3 class="function"><a name="finish_send-1">finish_send/1</a></h3>
<div class="spec">
<p><tt>finish_send(Handle::<a href="#type-handle">handle()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Complete sending the request body. Awaits the server's reply. Return
  values are as described for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="get-2">get/2</a></h3>
<div class="spec">
<p><tt>get(Client::<a href="#type-client">client()</a> | atom(), Url::binary()) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="get-3">get/3</a></h3>
<div class="spec">
<p><tt>get(Client::<a href="#type-client">client()</a> | atom(), Url::binary(), Opts::<a href="#type-req_opts_optional">req_opts_optional()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="make_client-0">make_client/0</a></h3>
<div class="spec">
<p><tt>make_client() -&gt; <a href="#type-client">client()</a></tt><br></p>
<p> </p>
</div><p>Equivalent to <a href="#make_client-1"><tt>make_client(#{})</tt></a>.</p>


<h3 class="function"><a name="make_client-1">make_client/1</a></h3>
<div class="spec">
<p><tt>make_client(Opts::<a href="#type-client_opts">client_opts()</a>) -&gt; <a href="#type-client">client()</a></tt><br></p>
<p> </p>
</div><p>Make a new client with its own connection pool. See also <a docgen-rel="seemfa" docgen-href="#start_client/2" href="#start_client-2"><code>start_client/2</code></a>.</p>

<h3 class="function"><a name="patch-3">patch/3</a></h3>
<div class="spec">
<p><tt>patch(Client::<a href="#type-client">client()</a> | atom(), Url::binary(), Opts::<a href="#type-req_opts_optional">req_opts_optional()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="post-3">post/3</a></h3>
<div class="spec">
<p><tt>post(Client::<a href="#type-client">client()</a> | atom(), Url::binary(), Opts::<a href="#type-req_opts_optional">req_opts_optional()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="put-3">put/3</a></h3>
<div class="spec">
<p><tt>put(Client::<a href="#type-client">client()</a> | atom(), Url::binary(), Opts::<a href="#type-req_opts_optional">req_opts_optional()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Convenience wrapper for <a docgen-rel="seemfa" docgen-href="#req/2" href="#req-2"><code>req/2</code></a>.</p>

<h3 class="function"><a name="read-1">read/1</a></h3>
<div class="spec">
<p><tt>read(Handle::<a href="#type-handle">handle()</a>) -&gt; {more, binary()} | {ok, binary()} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Equivalent to <a href="#read-2"><tt>read(Handle, #{})</tt></a>.</p>


<h3 class="function"><a name="read-2">read/2</a></h3>
<div class="spec">
<p><tt>read(Handle::<a href="#type-handle">handle()</a>, Opts::map() | cancel) -&gt; {more, binary()} | {ok, binary()} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Read a chunk of the response body, waiting for at most <code>period</code> ms or
  until at least <code>length</code> bytes have been read. Note that more than <code>length</code>
  bytes can be returned. Returns <code>{more, binary()}</code> if there is more data to be
  read, and <code>{ok, binary()}</code> once the body is complete.</p>

<h3 class="function"><a name="req-2">req/2</a></h3>
<div class="spec">
<p><tt>req(Client::<a href="#type-client">client()</a> | atom(), Req::<a href="#type-req_opts">req_opts()</a>) -&gt; {ok, <a href="#type-resp">resp()</a>} | {handle, <a href="#type-handle">handle()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p><p>Make a synchronous request.</p>
 
  Fails with reason badarg if any argument is invalid or if the client has
  already been closed. If you set <code>body</code> to <code>stream</code>, you will get back
  <code>{handle, handle()}</code>, which you need to pass to <a docgen-rel="seemfa" docgen-href="#send/2" href="#send-2"><code>send/2</code></a> and <a docgen-rel="seemfa" docgen-href="#finish_send/1" href="#finish_send-1"><code>finish_send/1</code></a> to stream the request body. If you set <code>response_body</code> to
  <code>stream</code>, the <code>body</code> key in <code>resp()</code> be a <code>handle()</code> that you need to pass to
  <code>read</code> to consume the response body. If you decide not to consume the
  response body, call <a docgen-rel="seemfa" docgen-href="#discard_body/1" href="#discard_body-1"><code>discard_body/1</code></a>.</p>

<h3 class="function"><a name="send-2">send/2</a></h3>
<div class="spec">
<p><tt>send(Handle::<a href="#type-handle">handle()</a>, Data::iodata()) -&gt; ok | {reply, <a href="#type-resp">resp()</a>} | {error, <a href="#type-err">err()</a>}</tt><br></p>
<p> </p>
</div><p>Stream a chunk of the request body. Returns <code>ok</code> once the chunk has
  successfully been queued for transmission. Note that due to buffering this
  does not mean that the chunk has actually been sent. Blocks once the internal
  buffer is full. Call <a docgen-rel="seemfa" docgen-href="#finish_send/1" href="#finish_send-1"><code>finish_send/1</code></a> once the body is complete.
  <code>{reply, resp()}</code> is returned if the server chooses to reply before the
  request body is complete.</p>

<h3 class="function"><a name="start_client-1">start_client/1</a></h3>
<div class="spec">
<p><tt>start_client(Name::atom()) -&gt; ok</tt><br></p>
<p> </p>
</div><p>Equivalent to <a href="#start_client-2"><tt>start_client(Name, #{})</tt></a>.</p>


<h3 class="function"><a name="start_client-2">start_client/2</a></h3>
<div class="spec">
<p><tt>start_client(Name::atom(), Opts::<a href="#type-client_opts">client_opts()</a>) -&gt; ok</tt><br></p>
<p> </p>
</div><p>Start a client registered under <code>Name</code>. The implementation uses
  <code>persistent_term</code> and is not intended for clients that will be frequently
  started and stopped. For such uses see <a docgen-rel="seemfa" docgen-href="#make_client/1" href="#make_client-1"><code>make_client/1</code></a>.</p>

<h3 class="function"><a name="stop_client-1">stop_client/1</a></h3>
<div class="spec">
<p><tt>stop_client(Name::atom()) -&gt; ok</tt><br></p>
<p> </p>
</div><p>Unregisters and calls <a docgen-rel="seemfa" docgen-href="#close_client/1" href="#close_client-1"><code>close_client/1</code></a> on a named client. This is
  potentially expensive and should not be called frequently, see <a docgen-rel="seemfa" docgen-href="#start_client/2" href="#start_client-2"><code>start_client/2</code></a> for more details.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
